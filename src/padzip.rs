use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};
use std::fs::OpenOptions;
use std::io::{Cursor, Error, ErrorKind, Read, Seek, SeekFrom, Write};

const KIBIBYTE: u64 = 1024;
const MEBIBYTE: u64 = 1024 * KIBIBYTE;
const GEBIBYTE: u64 = 1024 * MEBIBYTE;
const MAX_FILE_SIZE: u64 = 2 * GEBIBYTE;
const ZIP_CENTRAL_FILE_HEADER_MAGIC: u32 = 0x02014b50;
const ZIP_END_CENTRAL_DIRECTORY_MAGIC: &[u8; 4] = b"PK\x05\x06";

pub fn find_subsequence(haystack: &[u8], needle: &[u8]) -> Option<usize> {
    haystack
        .windows(needle.len())
        .position(|window| window == needle)
}

pub fn pad_zip_buffer(input_buf: &mut Vec<u8>, pad_length: u32) -> Result<u16, Error> {
    // TODO: Improve Scanning speed by:
    // Check last 2 bytes of file.
    //  If zero (length of file comment is 0), expect ZIP_END_CENTRAL_DIRECTORY_MAGIC at EOF-0x16
    //  If non-zero, skip -min(filesize, 2**16) and search from there.
    let zip_header_idx = match find_subsequence(&input_buf, ZIP_END_CENTRAL_DIRECTORY_MAGIC) {
        None => {
            return Err(Error::new(
                ErrorKind::InvalidData,
                "Could not find ZIP_END_CENTRAL_DIRECTORY_MAGIC",
            ));
        }
        Some(idx) => idx,
    };
    let mut input_cur = Cursor::new(input_buf);
    // +0x8 => entries on disk
    input_cur.seek(SeekFrom::Current((zip_header_idx + 0x8) as i64))?;
    let total_files = input_cur.read_u16::<LittleEndian>()?;

    #[cfg(debug_assertions)]
    println!("total files in ZIP: {:x}", total_files);

    match total_files {
        u16::MAX => {
            return Err(Error::new(
                ErrorKind::Unsupported,
                "ZIP64 files are not supported",
            ))
        }
        0 => return Ok(0),
        _ => {}
    }

    // Goto Offset to Central Directory Structure
    input_cur.seek(SeekFrom::Current(0x6))?;
    let first_zipdir_idx = input_cur.read_u32::<LittleEndian>()?;
    // Patch offset based on length of padding
    input_cur.seek(SeekFrom::Current(-0x4))?;
    input_cur.write_u32::<LittleEndian>(first_zipdir_idx + pad_length as u32)?;
    // Get to the first
    input_cur.seek(SeekFrom::Start(first_zipdir_idx as u64))?;
    let mut ctr = 0;
    while ctr < total_files {
        #[cfg(debug_assertions)]
        println!("zipentry index: {:x}", first_zipdir_idx);

        if ZIP_CENTRAL_FILE_HEADER_MAGIC != input_cur.read_u32::<LittleEndian>()? {
            return Err(Error::new(
                ErrorKind::InvalidData,
                format!(
                    "ZIP_CENTRAL_FILE_HEADER_MAGIC header not found for file#{}",
                    ctr + 1
                ),
            ));
        }
        input_cur.seek(SeekFrom::Current(0x18_i64))?;
        let filename_len = input_cur.read_u16::<LittleEndian>()?;
        let extrafield_len = input_cur.read_u16::<LittleEndian>()?;
        let filecomment_len = input_cur.read_u16::<LittleEndian>()?;

        #[cfg(debug_assertions)]
        println!(
            "\tFNL: {:x} EFL: {:x} FCL: {:x}",
            filename_len, extrafield_len, filecomment_len
        );
        // get to header start
        input_cur.seek(SeekFrom::Current(0x8_i64))?;
        let header_offset = input_cur.read_u32::<LittleEndian>()?;

        #[cfg(debug_assertions)]
        println!("\tHEADER OFF: {:x}", header_offset);

        let new_header_offset: u32 = pad_length + header_offset;

        #[cfg(debug_assertions)]
        println!("\tNEW-HEADER OFF: {:x}", new_header_offset);

        input_cur.seek(SeekFrom::Current(-4))?;
        input_cur.write_u32::<LittleEndian>(new_header_offset)?;
        input_cur.seek(SeekFrom::Current(
            (filename_len + extrafield_len + filecomment_len).into(),
        ))?;
        ctr += 1;
    }
    Ok(total_files + 1)
}

fn get_file_contents(
    input_filename: &str,
    max_file_size: Option<u64>,
) -> Result<Vec<u8>, std::io::Error> {
    let mut input_file = OpenOptions::new()
        .write(false)
        .read(true)
        .create(false)
        .open(input_filename)?;
    let file_len = match input_file.seek(SeekFrom::End(0)) {
        Ok(x) => x,
        Err(e) => return Err(e),
    };
    if file_len > max_file_size.unwrap_or(u64::MAX) {
        return Err(Error::new(
            ErrorKind::Other,
            format!(
                "{} is too large (> {} GB)",
                input_filename,
                max_file_size.unwrap() / GEBIBYTE
            ),
        ));
    }
    input_file.seek(SeekFrom::Start(0))?;
    let mut input_buf: Vec<u8> = Vec::with_capacity(file_len as usize);
    input_file.read_to_end(&mut input_buf)?;
    Ok(input_buf)
}

fn write_buffer_to_file(output_filename: &str, buf: &Vec<u8>) -> Result<(), std::io::Error> {
    let mut output_file = OpenOptions::new()
        .write(true)
        .read(true)
        .create(true)
        .open(output_filename)?;
    output_file.write_all(buf)
}

pub fn pad_zip_with_file(
    input_zip_filename: &str,
    pad_filename: &str,
    output_filename: &str,
) -> Result<u16, std::io::Error> {
    let mut input_buf = get_file_contents(input_zip_filename, Some(MAX_FILE_SIZE))?;
    let mut pad_buf = get_file_contents(pad_filename, Some(MAX_FILE_SIZE))?;
    pad_zip_buffer_and_write_to_file(&mut input_buf, &mut pad_buf, output_filename)
}

pub fn pad_zip_with_buffer(
    input_buf: &mut Vec<u8>,
    pad_buf: &mut Vec<u8>,
) -> Result<u16, std::io::Error> {
    let total_mods = pad_zip_buffer(input_buf, pad_buf.len() as u32)?;
    pad_buf.extend(input_buf.iter());
    Ok(total_mods)
}

fn pad_zip_buffer_and_write_to_file(
    input_buf: &mut Vec<u8>,
    pad_buf: &mut Vec<u8>,
    output_filename: &str,
) -> Result<u16, std::io::Error> {
    let total_mods = pad_zip_with_buffer(input_buf, pad_buf)?;
    write_buffer_to_file(output_filename, &pad_buf)?;
    Ok(total_mods)
}

pub fn create_zip_with_prefix(
    input_filename: &str,
    output_filename: &str,
    prefix_str: &str,
) -> Result<u16, std::io::Error> {
    let mut input_buf = get_file_contents(input_filename, Some(MAX_FILE_SIZE))?;
    let mut out_buf: Vec<u8> = Vec::with_capacity(input_buf.len() + prefix_str.len());
    out_buf.extend(prefix_str.as_bytes());
    pad_zip_buffer_and_write_to_file(&mut input_buf, &mut out_buf, output_filename)
}

#[test]
fn smallest_zip_file() {
    let mut min_zip = vec![
        0x50, 0x4b, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    let pad_str = "padme";
    let mut pad_buf = Vec::from(pad_str.as_bytes());
    let total_mods = pad_zip_with_buffer(&mut min_zip, &mut pad_buf).unwrap();
    // no mods required when there's zero files
    assert_eq!(total_mods, 0);
    assert_eq!(pad_buf.len(), min_zip.len() + pad_str.len());
    // no need to mod anything if there's no files in the ZIP
    assert_eq!(pad_buf[0x10 + pad_str.len()], min_zip[0x10])
    // println!("ssup");
}

#[test]
fn zip_with_single_file() {
    let mut single_file_zip = vec![
        0x50, 0x4B, 0x03, 0x04, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0x02, 0x7D, 0x53, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x61, 0x50, 0x4B, 0x01, 0x02, 0x3F, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0x02,
        0x7D, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x61, 0x0A, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x18, 0x00,
        0x43, 0x72, 0x79, 0x3C, 0xFA, 0xE4, 0xD7, 0x01, 0x43, 0x72, 0x79, 0x3C, 0xFA, 0xE4, 0xD7,
        0x01, 0x1E, 0x3E, 0xEA, 0x36, 0xFA, 0xE4, 0xD7, 0x01, 0x50, 0x4B, 0x05, 0x06, 0x00, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x53, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];
    let pad_str = "ThisIsASlightlyLongerPadding";
    let mut pad_buf = Vec::from(pad_str.as_bytes());
    let total_mods = pad_zip_with_buffer(&mut single_file_zip, &mut pad_buf).unwrap();
    assert_eq!(total_mods, 2);
    assert_eq!(pad_buf.len(), single_file_zip.len() + pad_str.len());
    assert_eq!(pad_buf[0x82 + pad_str.len()], 0x1F + pad_str.len() as u8)
}

#[test]
fn zip_with_six_files() {
    let mut zip_with_six_files = vec![
        0x50, 0x4B, 0x03, 0x04, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4F, 0x05, 0x7D, 0x53, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x61, 0x50, 0x4B, 0x03, 0x04, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4F, 0x05, 0x7D, 0x53,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
        0x00, 0x62, 0x50, 0x4B, 0x03, 0x04, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4F, 0x05, 0x7D,
        0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x00, 0x00, 0x63, 0x50, 0x4B, 0x03, 0x04, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4F, 0x05,
        0x7D, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x00, 0x00, 0x64, 0x50, 0x4B, 0x03, 0x04, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4F,
        0x05, 0x7D, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x65, 0x50, 0x4B, 0x03, 0x04, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x4F, 0x05, 0x7D, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x01, 0x00, 0x00, 0x00, 0x66, 0x50, 0x4B, 0x01, 0x02, 0x3F, 0x00, 0x0A, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x4F, 0x05, 0x7D, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x61, 0x0A, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x01, 0x00, 0x18, 0x00, 0x8F, 0xAC, 0x2A, 0x0B, 0xFD, 0xE4, 0xD7, 0x01, 0x8F, 0xAC,
        0x2A, 0x0B, 0xFD, 0xE4, 0xD7, 0x01, 0x8F, 0xAC, 0x2A, 0x0B, 0xFD, 0xE4, 0xD7, 0x01, 0x50,
        0x4B, 0x01, 0x02, 0x3F, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4F, 0x05, 0x7D, 0x53,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x24,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00,
        0x62, 0x0A, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x18, 0x00, 0x8F, 0xAC,
        0x2A, 0x0B, 0xFD, 0xE4, 0xD7, 0x01, 0x9F, 0xE0, 0x7F, 0x0D, 0xFD, 0xE4, 0xD7, 0x01, 0x9F,
        0xE0, 0x7F, 0x0D, 0xFD, 0xE4, 0xD7, 0x01, 0x50, 0x4B, 0x01, 0x02, 0x3F, 0x00, 0x0A, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x4F, 0x05, 0x7D, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x20, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x63, 0x0A, 0x00, 0x20, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x18, 0x00, 0x8F, 0xAC, 0x2A, 0x0B, 0xFD, 0xE4, 0xD7, 0x01, 0xBA,
        0x7C, 0xE9, 0x0C, 0xFD, 0xE4, 0xD7, 0x01, 0xBA, 0x7C, 0xE9, 0x0C, 0xFD, 0xE4, 0xD7, 0x01,
        0x50, 0x4B, 0x01, 0x02, 0x3F, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4F, 0x05, 0x7D,
        0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x5D, 0x00, 0x00,
        0x00, 0x64, 0x0A, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x18, 0x00, 0x8F,
        0xAC, 0x2A, 0x0B, 0xFD, 0xE4, 0xD7, 0x01, 0xA6, 0x3C, 0x50, 0x0E, 0xFD, 0xE4, 0xD7, 0x01,
        0xA6, 0x3C, 0x50, 0x0E, 0xFD, 0xE4, 0xD7, 0x01, 0x50, 0x4B, 0x01, 0x02, 0x3F, 0x00, 0x0A,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x4F, 0x05, 0x7D, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x20, 0x00, 0x00, 0x00, 0x7C, 0x00, 0x00, 0x00, 0x65, 0x0A, 0x00, 0x20, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x18, 0x00, 0x8F, 0xAC, 0x2A, 0x0B, 0xFD, 0xE4, 0xD7, 0x01,
        0x8C, 0xAF, 0x22, 0x0E, 0xFD, 0xE4, 0xD7, 0x01, 0x8C, 0xAF, 0x22, 0x0E, 0xFD, 0xE4, 0xD7,
        0x01, 0x50, 0x4B, 0x01, 0x02, 0x3F, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4F, 0x05,
        0x7D, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x9B, 0x00,
        0x00, 0x00, 0x66, 0x0A, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x18, 0x00,
        0x8F, 0xAC, 0x2A, 0x0B, 0xFD, 0xE4, 0xD7, 0x01, 0x85, 0x6F, 0xC4, 0x0D, 0xFD, 0xE4, 0xD7,
        0x01, 0x85, 0x6F, 0xC4, 0x0D, 0xFD, 0xE4, 0xD7, 0x01, 0x50, 0x4B, 0x05, 0x06, 0x00, 0x00,
        0x00, 0x00, 0x06, 0x00, 0x06, 0x00, 0xF2, 0x01, 0x00, 0x00, 0xBA, 0x00, 0x00, 0x00, 0x00,
        0x00,
    ];
    let pad_str = "<?xml version=";
    let mut pad_buf = Vec::from(pad_str.as_bytes());
    let total_mods = pad_zip_with_buffer(&mut zip_with_six_files, &mut pad_buf).unwrap();
    assert_eq!(total_mods, 7);
    assert_eq!(pad_buf.len(), zip_with_six_files.len() + pad_str.len());
    // final file record
    assert_eq!(pad_buf[0x283 + pad_str.len()], 0x9B + pad_str.len() as u8);
    // end of CDS record
    assert_eq!(pad_buf[0x2BC + pad_str.len()], 0xBA + pad_str.len() as u8);
    
}
